#!/usr/bin/env ruby
# frozen_string_literal: true

# (c) 2019 The Society of Research Software Engineering
#
# Author: Robert Haines

require 'rubygems'
require 'bundler'
require 'csv'

# Helper method for exiting on error.
def abort(message)
  warn message
  exit 1
end

# This many candidates are to be elected.
VOTING_CUTOFF = 12

abort 'Usage: count <csv input file>' unless ARGV.length == 1

csv_file = ARGV[0].chomp

abort "Cannot read input file '#{csv_file}'." unless ::File.readable? csv_file

# Grab all of the votes cast into one long list.
# Also, count the number of rows (voters), ignoring the header row.
all_votes = []
num_voters = 0
CSV.foreach(csv_file, headers: true) do |row|
  all_votes += row[3].split(',').map(&:strip)
  num_voters += 1
end

# Bucket the votes by name, and reverse sort by bucket value.
vote_buckets = all_votes.each_with_object(Hash.new(0)) do |name, bucket|
  bucket[name] += 1
end.sort_by(&:last).reverse

# Double check that we don't have more than 6 votes per person.
votes_pp = all_votes.length / num_voters
abort "Too many votes per person (#{votes_pp})" if votes_pp > 6

# Double check that the amount of votes in all buckets matches the
# total number of votes cast.
total_bucket_votes = vote_buckets.map(&:last).sum
if total_bucket_votes != all_votes.length
  abort 'Number of votes mismatched after bucketing ' \
    "(#{total_bucket_votes} but should be #{all_votes.length})"
end

# Insert the cutoff marker - purely decorative.
vote_buckets.insert(VOTING_CUTOFF, [' ----8<---- CUTOFF ----8<---- ', nil])

# Print the results.
puts "Soc RSE Trustee Elections 2019\n------------------------------"
puts "Number of voters: #{num_voters}"
puts "Total number of votes cast: #{all_votes.length}"
puts
puts 'Total number of votes for each candidate:'
vote_buckets.each do |name, votes|
  puts name.to_s.rjust(22) + votes.to_s.rjust(4)
end
